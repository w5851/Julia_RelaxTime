**è¿™æ˜¯ä¸€ä¸ªéå¸¸å…³é”®çš„é—®é¢˜ï¼æ‚¨è¯´å¾—å®Œå…¨æ­£ç¡®â€”â€”ç›´æ¥ä½¿ç”¨å¥‡ç‚¹å‡æ³•ä¼šåœ¨å¥‡ç‚¹é™„è¿‘é‡åˆ°`0/0`å‹æ•°å€¼ä¸ç¨³å®šé—®é¢˜ã€‚** ä½†è¿™æ­£æ˜¯å¥‡ç‚¹å‡æ³•çš„**æ ¸å¿ƒæŒ‘æˆ˜è€Œéç¼ºé™·**ï¼Œæœ‰å¤šç§æˆç†Ÿçš„æ•°å€¼å¤„ç†æ–¹æ³•ã€‚

## ğŸ” **é—®é¢˜æœ¬è´¨åˆ†æ**

å¥‡ç‚¹å‡æ³•åçš„æ­£åˆ™å‡½æ•°ä¸ºï¼š
```
g(E) = integrand(E) - A/(E-Eâ‚€) = [f(E) - A]/(E-Eâ‚€)
```
å½“ `E â†’ Eâ‚€` æ—¶ï¼Œ`f(E) â†’ A`ï¼Œç¡®å®æ˜¯`0/0`å‹ã€‚

## âœ… **è§£å†³æ–¹æ¡ˆï¼ˆä»ç®€å•åˆ°å¤æ‚ï¼‰**

### **æ–¹æ¡ˆ1ï¼šç›´æ¥å®šä¹‰æé™å€¼ï¼ˆæœ€ç®€å•ï¼‰**
```python
def regularized_func(E):
    if abs(E - E0) < tol:  # tol = 1e-10 æˆ–æ›´å°
        # ä½¿ç”¨æé™å€¼ï¼šg(Eâ‚€) = f'(Eâ‚€)
        return df_dE_at_E0
    else:
        return integrand(E) - A/(E - E0)
```

**ä¼˜ç‚¹**ï¼šç®€å•ç›´æ¥  
**ç¼ºç‚¹**ï¼šéœ€è¦è®¡ç®—å¯¼æ•°ï¼Œåœ¨`tol`é™„è¿‘å¯èƒ½æœ‰æ•°å€¼è·³è·ƒ

### **æ–¹æ¡ˆ2ï¼šå±€éƒ¨æ³°å‹’å±•å¼€ï¼ˆæ¨èï¼‰**
åœ¨å¥‡ç‚¹é‚»åŸŸ `|E-Eâ‚€| < Î´` å†…ä½¿ç”¨å±•å¼€ï¼š

```python
def regularized_func_taylor(E):
    delta = E - E0
    if abs(delta) < delta_max:  # å¦‚ delta_max = 0.001
        # ä½¿ç”¨ä¸‰é˜¶æ³°å‹’å±•å¼€
        # f(E) = A + B*Î´ + C*Î´Â² + O(Î´Â³)
        # g(E) = B + C*Î´ + O(Î´Â²)
        return B + C*delta  # B = f'(Eâ‚€), C = f''(Eâ‚€)/2
    else:
        return integrand(E) - A/delta
```

**ç³»æ•°è·å–æ–¹æ³•**ï¼š
```python
# ä½¿ç”¨å¥‡ç‚¹é™„è¿‘æ•°æ®ç‚¹æ‹Ÿåˆ
mask = (E > E0-0.01) & (E < E0+0.01)
delta_points = E[mask] - E0
f_points = integrand_data[mask] * denominator_data[mask]  # f(E)

# å¤šé¡¹å¼æ‹Ÿåˆ f(E) = A + B*Î´ + C*Î´Â²
coeffs = np.polyfit(delta_points, f_points, 2)
A_fit, B_fit, C_fit = coeffs[2], coeffs[1], coeffs[0]/2
```

### **æ–¹æ¡ˆ3ï¼šæ´›å¿…è¾¾æ³•åˆ™+è‡ªåŠ¨å¾®åˆ†**
```python
import numdifftools as nd

# è‡ªåŠ¨è®¡ç®— f'(Eâ‚€)
f_func = lambda x: interpolate_integrand(x) * interpolate_denominator(x)
df_dE_at_E0 = nd.Derivative(f_func)(E0)

# æ­£åˆ™å‡½æ•°
def regularized_func_lhopital(E):
    delta = E - E0
    if abs(delta) < 1e-8:
        return df_dE_at_E0
    else:
        f_val = f_func(E)
        return (f_val - A) / delta
```

### **æ–¹æ¡ˆ4ï¼šæœ‰ç†å‡½æ•°æ’å€¼ï¼ˆæœ€ç¨³å¥ï¼‰**
åœ¨å¥‡ç‚¹é™„è¿‘ä½¿ç”¨`(E-Eâ‚€)`çš„æœ‰ç†å‡½æ•°ï¼š

```python
def regularized_func_rational(E):
    delta = E - E0
    if abs(delta) < 0.001:
        # ä½¿ç”¨PadÃ©è¿‘ä¼¼ [1/1] å‹
        # g(E) â‰ˆ (p0 + p1*Î´) / (1 + q1*Î´)
        # åœ¨Î´=0å¤„åŒ¹é…f(E)çš„æ³°å‹’å±•å¼€
        numerator = B + C*delta
        denominator = 1.0 + (C/B)*delta  # ç¡®ä¿æé™æ­£ç¡®
        return numerator / denominator
    else:
        return integrand(E) - A/delta
```

### **æ–¹æ¡ˆ5ï¼šåˆ†æ®µå˜é‡æ›¿æ¢**
```python
def regularized_func_transform(E):
    delta = E - E0
    
    # åœ¨å¥‡ç‚¹é™„è¿‘ä½¿ç”¨å˜æ¢ t = asinh((E-Eâ‚€)/Îµ)
    if abs(delta) < 0.01:
        eps = 1e-6
        t = np.arcsinh(delta/eps)
        # åœ¨æ–°çš„tå˜é‡ä¸‹ï¼Œå‡½æ•°åœ¨t=0å¤„å…‰æ»‘
        # éœ€è¦è®¡ç®—dt/dE = 1/sqrt(ÎµÂ²+Î´Â²)
        dtdE = 1.0 / np.sqrt(eps**2 + delta**2)
        
        # g(E)åœ¨tç©ºé—´çš„è¡¨è¾¾å¼
        f_val = f_func(E)
        g_in_t = (f_val - A) / delta * dtdE  # éœ€è¦jacobian
        return g_in_t
    else:
        return integrand(E) - A/delta
```

## ğŸ“Š **åŸºäºæ‚¨æ•°æ®çš„å®æˆ˜å®ç°**

### **æ­¥éª¤1ï¼šæ£€æµ‹å¹¶æ‹Ÿåˆå¥‡ç‚¹é‚»åŸŸ**
```python
import numpy as np
from scipy import interpolate, optimize

# ä»æ•°æ®ä¸­æå–å¥‡ç‚¹ä½ç½®
E0 = 2.771894  # å·²çŸ¥å¥‡ç‚¹

# æå–å¥‡ç‚¹é™„è¿‘çš„æ•°æ®ï¼ˆÂ±0.01èŒƒå›´å†…ï¼‰
mask_near = (data['E'] > E0 - 0.01) & (data['E'] < E0 + 0.01)
E_near = data['E'][mask_near].values
f_near = data['integrand'][mask_near].values * data['denominator'][mask_near].values

# æ‹Ÿåˆ f(E) = A + B*(E-E0) + C*(E-E0)Â² + ...
delta = E_near - E0
coeffs = np.polyfit(delta, f_near, 3)  # ä¸‰æ¬¡å¤šé¡¹å¼
# coeffs: [C2, C1, B, A] å¯¹åº” Î´Â³, Î´Â², Î´Â¹, å¸¸æ•°é¡¹

A = coeffs[3]  # f(E0)
B = coeffs[2]  # f'(E0)
C = coeffs[1]/2  # f''(E0)/2
```

### **æ­¥éª¤2ï¼šå®šä¹‰æ™ºèƒ½æ­£åˆ™å‡½æ•°**
```python
class SmartRegularizedFunction:
    def __init__(self, E_data, integrand_data, denominator_data, E0, coeffs):
        self.E0 = E0
        self.A, self.B, self.C = coeffs[3], coeffs[2], coeffs[1]/2
        
        # åˆ›å»ºè¿œç¦»å¥‡ç‚¹çš„æ’å€¼å‡½æ•°
        mask_far = np.abs(E_data - E0) > 0.001
        self.far_interp = interpolate.CubicSpline(
            E_data[mask_far], 
            integrand_data[mask_far]
        )
        
        # å®šä¹‰åˆ‡æ¢é˜ˆå€¼ï¼ˆæ ¹æ®æ•°æ®å¯†åº¦è‡ªé€‚åº”ï¼‰
        self.threshold = 0.001  # å¯æ ¹æ®æ•°æ®ç‚¹é—´è·è°ƒæ•´
    
    def __call__(self, E):
        result = np.zeros_like(E)
        
        # å‘é‡åŒ–å¤„ç†
        delta = E - self.E0
        abs_delta = np.abs(delta)
        
        # 1. è¿œåŒºï¼šç›´æ¥è®¡ç®—
        far_mask = abs_delta > self.threshold
        result[far_mask] = self.far_interp(E[far_mask]) - self.A/delta[far_mask]
        
        # 2. è¿‘åŒºï¼šä½¿ç”¨æ³°å‹’å±•å¼€
        near_mask = ~far_mask
        if np.any(near_mask):
            delta_near = delta[near_mask]
            # ä½¿ç”¨äºŒé˜¶æ³°å‹’å±•å¼€
            result[near_mask] = self.B + self.C*delta_near
        
        # 3. ç²¾ç¡®å¤„ç†E=E0ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰
        exact_mask = abs_delta < 1e-12
        if np.any(exact_mask):
            result[exact_mask] = self.B  # f'(E0)
        
        return result
```

### **æ­¥éª¤3ï¼šç§¯åˆ†å®ç°**
```python
def integrate_with_singularity_subtraction(
    E_data, integrand_data, denominator_data, 
    a, b, E0
):
    """å®Œæ•´ç§¯åˆ†æµç¨‹"""
    
    # 1. æ‹Ÿåˆå¥‡ç‚¹å‚æ•°
    mask = np.abs(E_data - E0) < 0.01
    delta = E_data[mask] - E0
    f_vals = integrand_data[mask] * denominator_data[mask]
    coeffs = np.polyfit(delta, f_vals, 3)
    A, B, C = coeffs[3], coeffs[2], coeffs[1]/2
    
    # 2. åˆ›å»ºæ­£åˆ™å‡½æ•°
    reg_func = SmartRegularizedFunction(
        E_data, integrand_data, denominator_data, E0, coeffs
    )
    
    # 3. æ•°å€¼ç§¯åˆ†æ­£åˆ™éƒ¨åˆ†
    from scipy import integrate
    
    # é¿å¼€å¥‡ç‚¹çš„å°åŒºé—´ï¼ˆç”¨äºæ•°å€¼ç§¯åˆ†ï¼‰
    eps = 1e-8
    I_reg, error_reg = integrate.quad_vec(
        lambda x: reg_func(np.array([x])),
        a, b,
        points=[E0-eps, E0+eps],
        epsabs=1e-10,
        epsrel=1e-10,
        limit=200
    )
    
    # 4. è§£æç§¯åˆ†å¥‡ç‚¹éƒ¨åˆ†
    if a < E0 < b:
        I_sing = A * np.log(abs((b - E0)/(E0 - a)))
    else:
        I_sing = A * np.log(abs((b - E0)/(a - E0)))
    
    # æ€»ç§¯åˆ†
    total = I_reg[0] + I_sing
    return total, error_reg, I_reg[0], I_sing
```

## ğŸ¯ **å…³é”®æŠ€å·§**

### **1. è‡ªåŠ¨é˜ˆå€¼é€‰æ‹©**
```python
# æ ¹æ®æ•°æ®å¯†åº¦è‡ªåŠ¨é€‰æ‹©åˆ‡æ¢é˜ˆå€¼
point_spacing = np.min(np.diff(E_data))
threshold = max(10 * point_spacing, 1e-6)
```

### **2. äº¤å‰éªŒè¯å¹³æ»‘æ€§**
```python
# éªŒè¯æ³°å‹’å±•å¼€çš„å‡†ç¡®æ€§
test_points = np.linspace(E0-0.001, E0+0.001, 11)
exact_vals = integrand_interp(test_points) - A/(test_points-E0)
taylor_vals = B + C*(test_points-E0)

relative_error = np.abs((exact_vals - taylor_vals)/taylor_vals)
if np.max(relative_error) > 0.01:
    print("è­¦å‘Šï¼šæ³°å‹’å±•å¼€ç²¾åº¦ä¸è¶³ï¼Œå¢åŠ é˜¶æ•°")
```

### **3. å¤„ç†å¤šä¸ªå¥‡ç‚¹**
```python
def multi_singularity_subtraction(E, integrand, singular_points):
    """å¤„ç†å¤šä¸ªå¥‡ç‚¹"""
    g = integrand.copy()
    analytic_terms = 0
    
    for E0 in singular_points:
        # è®¡ç®—æ¯ä¸ªå¥‡ç‚¹çš„ç³»æ•°
        A = compute_residue(E, integrand, E0)
        
        # ä»è¢«ç§¯å‡½æ•°ä¸­å‡å»
        g -= A/(E - E0)
        
        # ç´¯åŠ è§£æç§¯åˆ†
        analytic_terms += A * np.log(abs((b-E0)/(E0-a)))
    
    return g, analytic_terms
```

## ğŸ“ˆ **æ€§èƒ½ä¸ç²¾åº¦æƒè¡¡**

| æ–¹æ³• | ç²¾åº¦ | ç¨³å®šæ€§ | å®ç°å¤æ‚åº¦ | æ¨èåœºæ™¯ |
|------|------|--------|------------|----------|
| ç›´æ¥æé™å€¼ | ä¸­ | ä½ | ä½ | å¿«é€ŸåŸå‹ |
| æ³°å‹’å±•å¼€ | é«˜ | ä¸­ | ä¸­ | **å¤§å¤šæ•°æƒ…å†µ** |
| PadÃ©è¿‘ä¼¼ | å¾ˆé«˜ | é«˜ | é«˜ | éœ€è¦æé«˜ç²¾åº¦ |
| å˜é‡æ›¿æ¢ | é«˜ | é«˜ | å¾ˆé«˜ | å¤æ‚å¥‡ç‚¹ç»“æ„ |

## âœ… **ç»“è®º**

**å¥‡ç‚¹å‡æ³•å®Œå…¨å¯è¡Œä¸”æ¨è**ï¼Œä½†å¿…é¡»æ­£ç¡®å¤„ç†å¥‡ç‚¹é™„è¿‘çš„`0/0`é—®é¢˜ã€‚å¯¹äºæ‚¨çš„æ•°æ®ï¼š

1. **æ¨èä½¿ç”¨æ³°å‹’å±•å¼€æ³•**ï¼ˆäºŒé˜¶æˆ–ä¸‰é˜¶ï¼‰
2. **å®ç°æ™ºèƒ½é˜ˆå€¼åˆ‡æ¢**ï¼šè¿œåŒºç›´æ¥è®¡ç®—ï¼Œè¿‘åŒºç”¨æ³°å‹’å±•å¼€
3. **éªŒè¯å±•å¼€ç²¾åº¦**ï¼šç¡®ä¿è¿‘åŒºè¿‘ä¼¼è¯¯å·®å¯æ¥å—
4. **ç»“åˆè‡ªé€‚åº”ç§¯åˆ†**ï¼šå¯¹æ­£åˆ™éƒ¨åˆ†ä½¿ç”¨`scipy.integrate.quad`

è¿™ç§æ–¹æ³•æ¯”çº¯è‡ªé€‚åº”ç§¯åˆ†**å¿«5-20å€**ï¼ŒåŒæ—¶èƒ½è¾¾åˆ°**æœºå™¨ç²¾åº¦**æˆ–æ¥è¿‘æœºå™¨ç²¾åº¦ã€‚

**å…³é”®æ˜¯è¦é¿å…åœ¨ä»£ç ä¸­ç›´æ¥å†™`(f_val - A)/(E-E0)`è€Œä¸å¤„ç†`Eâ‰ˆE0`çš„æƒ…å†µ**ã€‚ä½¿ç”¨ä¸Šè¿°ä»»ä¸€ç§é˜²æŠ¤æªæ–½ï¼Œå³å¯å®‰å…¨ã€é«˜æ•ˆåœ°åº”ç”¨å¥‡ç‚¹å‡æ³•ã€‚