# 自动化散射过程总传播子计算 - 使用指南

## 功能概述

新增的自动化功能允许根据散射过程符号自动计算所有相关散射道的总传播子，无需手动指定介子列表。

### 核心优势

1. **自动化介子查询**：根据散射过程自动从映射表查询介子列表
2. **智能分类计算**：自动区分一般介子和混合介子，分别计算并求和
3. **类型安全**：散射过程和介子映射关系集中在常量表中维护
4. **批量计算**：一次调用计算所有相关散射道（qq散射计算t/u道，qqbar散射计算t/s道）

## 支持的散射过程

### 夸克-夸克散射（4个，有t道和u道）

| 散射过程 | 符号 | t道介子 | u道介子 |
|---------|------|---------|---------|
| u u → u u | `:uu_to_uu` | π, η/η', σ_π, σ/σ' | π, η/η', σ_π, σ/σ' |
| s s → s s | `:ss_to_ss` | η/η', σ/σ' | η/η', σ/σ' |
| u d → u d | `:ud_to_ud` | π, η/η', σ_π, σ/σ' | π, σ_π |
| u s → u s | `:us_to_us` | η/η', σ/σ' | K, σ_K |

### 夸克-反夸克散射（7个，有t道和s道）

| 散射过程 | 符号 | t道介子 | s道介子 |
|---------|------|---------|---------|
| u đ → u đ | `:udbar_to_udbar` | π, η/η', σ_π, σ/σ' | π, σ_π |
| u s̄ → u s̄ | `:usbar_to_usbar` | η/η', σ/σ' | K, σ_K |
| u ū → u ū | `:uubar_to_uubar` | π, η/η', σ_π, σ/σ' | π, η/η', σ_π, σ/σ' |
| u ū → d đ | `:uubar_to_ddbar` | π, σ_π | π, η/η', σ_π, σ/σ' |
| u ū → s s̄ | `:uubar_to_ssbar` | K, σ_K | η/η', σ/σ' |
| s s̄ → u ū | `:ssbar_to_uubar` | K, σ_K | η/η', σ/σ' |
| s s̄ → s s̄ | `:ssbar_to_ssbar` | η/η', σ/σ' | η/η', σ/σ' |

## API 接口

### 1. `calculate_all_propagators` - 批量计算所有散射道

**推荐使用**：一次调用计算所有相关散射道。

```julia
result = calculate_all_propagators(process, k0, k_norm, 
                                   quark_params, thermo_params, K_coeffs)
```

#### 返回值
- **qq散射**：`(t = D_t, u = D_u)`
- **qqbar散射**：`(t = D_t, s = D_s)`

#### 示例

```julia
using .TotalPropagator: calculate_all_propagators

# 夸克-夸克散射：返回t道和u道
result = calculate_all_propagators(:uu_to_uu, k0, k_norm, 
                                   quark_params, thermo_params, K_coeffs)
println("D_t = ", result.t, " fm²")
println("D_u = ", result.u, " fm²")

# 夸克-反夸克散射：返回t道和s道
result = calculate_all_propagators(:uubar_to_uubar, k0, k_norm,
                                   quark_params, thermo_params, K_coeffs)
println("D_t = ", result.t, " fm²")
println("D_s = ", result.s, " fm²")
```

### 2. `total_propagator_auto` - 单个散射道计算

计算指定散射过程的单个散射道。

```julia
D = total_propagator_auto(process, channel, k0, k_norm,
                          quark_params, thermo_params, K_coeffs)
```

#### 示例

```julia
using .TotalPropagator: total_propagator_auto

# 计算特定散射道
D_t = total_propagator_auto(:uu_to_uu, :t, k0, k_norm,
                            quark_params, thermo_params, K_coeffs)

D_u = total_propagator_auto(:uu_to_uu, :u, k0, k_norm,
                            quark_params, thermo_params, K_coeffs)
```

## 完整使用示例

```julia
using .TotalPropagator: calculate_all_propagators
using .EffectiveCouplings: calculate_effective_couplings, calculate_G_from_A
using .OneLoopIntegrals: A
using .GaussLegendre: gauleg
using .Constants_PNJL: G_fm2, K_fm5, ħc_MeV_fm

# === 步骤1：设置物理参数 ===
T_MeV = 150.0
m_u_MeV = 300.0
m_s_MeV = 500.0

T = T_MeV / ħc_MeV_fm
m_u = m_u_MeV / ħc_MeV_fm
m_s = m_s_MeV / ħc_MeV_fm
μ_u = 0.0
μ_s = 0.0
Φ = 0.5
Φbar = 0.5
ξ = 0.0

k0 = 100.0 / ħc_MeV_fm
k_norm = 50.0 / ħc_MeV_fm

# === 步骤2：计算A函数和K系数 ===
nodes_p, weights_p = gauleg(0.0, 20.0, 64)
A_u = A(m_u, μ_u, T, Φ, Φbar, nodes_p, weights_p)
A_s = A(m_s, μ_s, T, Φ, Φbar, nodes_p, weights_p)

G_u = calculate_G_from_A(A_u)
G_s = calculate_G_from_A(A_s)
K_coeffs = calculate_effective_couplings(G_fm2, K_fm5, G_u, G_s)

# === 步骤3：构造参数结构 ===
quark_params = (
    m = (u = m_u, d = m_u, s = m_s),
    μ = (u = μ_u, d = μ_u, s = μ_s),
    A = (u = A_u, d = A_u, s = A_s)
)

thermo_params = (T = T, Φ = Φ, Φbar = Φbar, ξ = ξ)

# === 步骤4：计算散射过程的所有传播子 ===

# 示例1：u+u→u+u 散射（qq类型，返回t和u道）
result_uu = calculate_all_propagators(:uu_to_uu, k0, k_norm,
                                      quark_params, thermo_params, K_coeffs)
println("u+u→u+u:")
println("  D_t = ", result_uu.t, " fm²")
println("  D_u = ", result_uu.u, " fm²")

# 示例2：u+ū→u+ū 散射（qqbar类型，返回t和s道）
result_uubar = calculate_all_propagators(:uubar_to_uubar, k0, k_norm,
                                         quark_params, thermo_params, K_coeffs)
println("u+ū→u+ū:")
println("  D_t = ", result_uubar.t, " fm²")
println("  D_s = ", result_uubar.s, " fm²")

# 示例3：批量计算所有散射过程
all_processes = [:uu_to_uu, :ss_to_ss, :ud_to_ud, :us_to_us,
                 :udbar_to_udbar, :usbar_to_usbar, :uubar_to_uubar,
                 :uubar_to_ddbar, :uubar_to_ssbar, :ssbar_to_uubar, :ssbar_to_ssbar]

for process in all_processes
    result = calculate_all_propagators(process, k0, k_norm,
                                       quark_params, thermo_params, K_coeffs)
    println("$process: ", result)
end
```

## 内部工作原理

### 1. 常量映射表（Constants_PNJL.jl）

```julia
const SCATTERING_MESON_MAP = Dict{Symbol, Dict}(
    :uu_to_uu => Dict(
        :type => :qq,  # 散射类型
        :channels => Dict(
            :t => Dict(
                :simple => [:pi, :sigma_pi],    # 一般介子
                :mixed_P => true,                # 是否有η/η'
                :mixed_S => true                 # 是否有σ/σ'
            ),
            :u => Dict(...)
        )
    ),
    # ... 其他散射过程
)
```

### 2. 计算流程

对于每个散射道，自动执行以下步骤：

1. **查询介子列表**：从 `SCATTERING_MESON_MAP` 获取该散射道的介子配置
2. **计算一般介子**：如果 `:simple` 列表非空，调用 `total_propagator_simple`
3. **计算混合介子**：
   - 如果 `:mixed_P => true`：调用 `total_propagator_mixed(..., :P)` 计算η/η'贡献
   - 如果 `:mixed_S => true`：调用 `total_propagator_mixed(..., :S)` 计算σ/σ'贡献
4. **求和**：将所有贡献相加得到总传播子

### 3. 介子分类说明

- **一般介子**（`:simple` 列表）：
  - `:pi`（π介子）
  - `:K`（K介子）
  - `:sigma_pi`（σ_π介子）
  - `:sigma_K`（σ_K介子）

- **混合介子**（布尔标记）：
  - `:mixed_P => true`：存在赝标量混合介子η和η'（作为整体计算一次）
  - `:mixed_S => true`：存在标量混合介子σ和σ'（作为整体计算一次）

## 错误处理

### 未知散射过程

```julia
julia> calculate_all_propagators(:invalid_process, ...)
ERROR: Unknown scattering process: invalid_process. 
Supported processes: ss_to_ss, ssbar_to_ssbar, ...
```

### 不适用的散射道

```julia
julia> total_propagator_auto(:uu_to_uu, :s, ...)  # qq散射没有s道
ERROR: Scattering process uu_to_uu (qq type) only has t and u channels, not s

julia> total_propagator_auto(:uubar_to_uubar, :u, ...)  # qqbar散射没有u道
ERROR: Scattering process uubar_to_uubar (qqbar type) only has t and s channels, not u
```

## 性能优化

1. **极化函数缓存**：所有极化函数调用自动缓存，相同参数只计算一次
2. **K系数复用**：K系数可在多个散射过程间复用
3. **A函数预计算**：A函数只依赖热力学参数，可在外部预先计算

## 与原有接口的关系

### 原有接口（仍然可用）

```julia
# 需要手动指定介子列表
D = total_propagator_simple(process, channel, [:pi, :K], 
                            k0, k_norm, quark_params, thermo_params, K_coeffs)
```

### 新接口（推荐）

```julia
# 自动查询介子列表
D = total_propagator_auto(process, channel,
                         k0, k_norm, quark_params, thermo_params, K_coeffs)
```

**建议**：新代码使用自动化接口，旧代码可以逐步迁移。

## 扩展新散射过程

要添加新的散射过程，只需在 `Constants_PNJL.jl` 中的 `SCATTERING_MESON_MAP` 添加条目：

```julia
const SCATTERING_MESON_MAP = Dict{Symbol, Dict}(
    # ... 现有散射过程 ...
    
    # 新增散射过程
    :new_process => Dict(
        :type => :qq,  # 或 :qqbar
        :channels => Dict(
            :t => Dict(:simple => [:pi], :mixed_P => true, :mixed_S => false),
            :u => Dict(:simple => [:K], :mixed_P => false, :mixed_S => false)
        )
    )
)
```

无需修改任何计算代码！

## 常见问题

### Q: 为什么缓存命中率是0%？
A: 在单次计算中，每个(k0, k_norm, channel)组合的极化函数只会被请求一次，因此看不到缓存效果。缓存的优势在于批量计算多个散射过程或扫描参数空间时体现。

### Q: 如何获取单个介子的传播子？
A: 使用原有的 `total_propagator_simple` 接口，传入单个介子列表：
```julia
D_pi = total_propagator_simple(:uu_to_uu, :t, [:pi], ...)
```

### Q: 混合介子η和η'可以分别计算吗？
A: 不可以。根据物理理论，η和η'是SU(3)单态和八重态的混合态，必须作为整体计算。

### Q: 如何验证映射表的正确性？
A: 参考 `docs/reference/formula/relaxtime/scattering/ScatteringProcesses_AllPossible.md` 中的表格，与常量表对照检查。

## 参考文献

- 散射过程列表：`docs/reference/formula/relaxtime/scattering/ScatteringProcesses_AllPossible.md`
- 传播子公式：`docs/reference/formula/relaxtime/propagator/Propagator_传播子byPolarization.md`
- 总传播子公式：`docs/reference/formula/relaxtime/propagator/总传播子byPropagator.md`
