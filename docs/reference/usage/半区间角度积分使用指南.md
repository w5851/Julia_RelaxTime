# 半区间角度积分节点使用指南

## 概述

`DEFAULT_COSΘ_HALF_NODES` 是专门为**对称被积函数**设计的高精度积分节点，积分区间为 [0, 1]（对应 cosθ ∈ [0, 1]）。

## 数学原理

对于关于 cosθ = 0 对称的函数 f(cosθ) = f(-cosθ)，有：

```math
∫_{-1}^{1} f(\cos\theta) \, d(\cos\theta) = 2 \int_{0}^{1} f(\cos\theta) \, d(\cos\theta)
```

使用半区间积分的优势：
- **相同节点数，更高精度**：节点在 [0, 1] 区间内更密集
- **避免重复计算**：利用对称性减少一半的函数求值
- **数值稳定性更好**：在某些情况下避免了正负值相消的数值误差

## 使用方法

### 基本用法

```julia
using .GaussLegendre: DEFAULT_COSΘ_HALF_NODES, DEFAULT_COSΘ_HALF_WEIGHTS

# 对于对称函数 f
function symmetric_function(cosθ)
    return cosθ^2  # 例如：偶函数
end

# 计算积分（注意乘以因子 2）
result = 2.0 * sum(DEFAULT_COSΘ_HALF_WEIGHTS .* symmetric_function.(DEFAULT_COSΘ_HALF_NODES))
```

### 对比：全区间 vs 半区间

```julia
using .GaussLegendre: DEFAULT_COSΘ_NODES, DEFAULT_COSΘ_WEIGHTS,
                       DEFAULT_COSΘ_HALF_NODES, DEFAULT_COSΘ_HALF_WEIGHTS

function test_function(cosθ)
    return exp(-cosθ^2)
end

# 方法1: 全区间积分 (32节点)
result_full = sum(DEFAULT_COSΘ_WEIGHTS .* test_function.(DEFAULT_COSΘ_NODES))

# 方法2: 半区间对称积分 (32节点，但精度更高)
result_half = 2.0 * sum(DEFAULT_COSΘ_HALF_WEIGHTS .* test_function.(DEFAULT_COSΘ_HALF_NODES))

println("全区间方法: ", result_full)
println("半区间方法: ", result_half)
println("相对差异:   ", abs(result_full - result_half) / result_full * 100, " %")
```

## 适用场景

### ✓ 适合使用的情况

1. **偶函数**
   ```julia
   f(x) = x^2        # f(x) = f(-x)
   f(x) = cos(x)     # f(x) = f(-x)
   f(x) = exp(-x^2)  # f(x) = f(-x)
   ```

2. **各向同性分布**
   ```julia
   # 费米-狄拉克分布（各向同性）
   function fermi_dirac_isotropic(cosθ, p, m, μ, T)
       E = sqrt(p^2 + m^2)  # 不依赖于角度
       return 1.0 / (1.0 + exp((E - μ) / T))
   end
   ```

3. **偶数阶勒让德多项式**
   ```julia
   # P₀, P₂, P₄, ... 是偶函数
   f(x) = 0.5 * (3x^2 - 1)  # P₂(x)
   ```

### ✗ 不适合使用的情况

1. **奇函数**
   ```julia
   f(x) = x          # f(-x) = -f(x)
   f(x) = sin(x)     # f(-x) = -f(x)
   # 对于奇函数，∫₋₁¹ f(x)dx = 0，但半区间方法会得到错误结果
   ```

2. **非对称函数**
   ```julia
   f(x) = exp(x)     # f(x) ≠ f(-x)
   f(x) = x + x^2    # 包含奇次项
   ```

3. **角度依赖的物理量（各向异性）**
   ```julia
   # 带角度依赖的分布
   function anisotropic_distribution(cosθ, ξ)
       return f_0 * (1.0 + ξ * cosθ^2)  # 各向异性修正
   end
   # 虽然这个函数是偶函数，但如果需要分析角度依赖性，建议使用全区间
   ```

## 物理应用示例

### 示例1: 夸克数密度（各向同性）

```julia
using .GaussLegendre: DEFAULT_MOMENTUM_NODES, DEFAULT_MOMENTUM_WEIGHTS,
                       DEFAULT_COSΘ_HALF_NODES, DEFAULT_COSΘ_HALF_WEIGHTS

function quark_number_density(m, μ, T)
    density = 0.0
    
    # 动量积分
    for i in eachindex(DEFAULT_MOMENTUM_NODES)
        p = DEFAULT_MOMENTUM_NODES[i]
        w_p = DEFAULT_MOMENTUM_WEIGHTS[i]
        E = sqrt(p^2 + m^2)
        
        # 费米-狄拉克分布（各向同性，关于cosθ对称）
        f_FD = 1.0 / (1.0 + exp((E - μ) / T))
        
        # 角度积分（利用对称性）
        # ∫₋₁¹ d(cosθ) = 2 ∫₀¹ d(cosθ)
        angle_integral = 2.0 * sum(DEFAULT_COSΘ_HALF_WEIGHTS)
        
        density += w_p * p^2 * f_FD * angle_integral
    end
    
    return density / (2π)^2  # 归一化
end
```

### 示例2: 标量介子传播子的真空部分

```julia
function vacuum_bubble_symmetric(m, k_magnitude)
    result = 0.0
    
    # 对于真空项，积分是对称的
    for i in eachindex(DEFAULT_MOMENTUM_NODES)
        p = DEFAULT_MOMENTUM_NODES[i]
        w_p = DEFAULT_MOMENTUM_WEIGHTS[i]
        
        # 角度积分（对称被积函数）
        angle_integral = 0.0
        for j in eachindex(DEFAULT_COSΘ_HALF_NODES)
            cosθ = DEFAULT_COSΘ_HALF_NODES[j]
            w_θ = DEFAULT_COSΘ_HALF_WEIGHTS[j]
            
            E_p = sqrt(p^2 + m^2)
            q_squared = p^2 + k_magnitude^2 - 2*p*k_magnitude*cosθ
            E_q = sqrt(q_squared + m^2)
            
            denominator = E_p + E_q
            angle_integral += w_θ / denominator
        end
        
        # 乘以对称因子 2
        result += w_p * p^2 * 2.0 * angle_integral
    end
    
    return result
end
```

## 精度测试结果

根据 `test_cosθ_half_precision.jl` 的测试结果：

| 测试函数 | 全区间误差 | 半区间误差 | 精度提升 |
|---------|-----------|-----------|---------|
| f(x) = x² | 3.3×10⁻¹⁴ % | 0 % | ∞× |
| f(x) = exp(-x²) | 1.5×10⁻¹⁴ % | 1.5×10⁻¹⁴ % | ~1× |
| 物理函数（类费米分布） | 1.3×10⁻¹³ % | 2.7×10⁻¹⁴ % | 5× |

## 性能建议

1. **对称函数优先使用半区间**：精度更高，计算量相同
2. **非对称函数使用全区间**：避免错误结果
3. **不确定时先测试**：对比两种方法的结果差异
4. **混合使用**：不同物理量可以选择不同的积分方法

## 注意事项

⚠️ **必须乘以因子 2**
```julia
# 正确 ✓
result = 2.0 * sum(DEFAULT_COSΘ_HALF_WEIGHTS .* f.(DEFAULT_COSΘ_HALF_NODES))

# 错误 ✗（忘记乘以2）
result = sum(DEFAULT_COSΘ_HALF_WEIGHTS .* f.(DEFAULT_COSΘ_HALF_NODES))
```

⚠️ **验证对称性**
```julia
# 测试函数是否对称
function test_symmetry(f, tol=1e-10)
    for x in [-0.9, -0.5, -0.1, 0.1, 0.5, 0.9]
        if abs(f(x) - f(-x)) > tol
            println("⚠️ 函数在 x = $x 处不对称")
            return false
        end
    end
    println("✓ 函数通过对称性检验")
    return true
end
```

## 参考

- 测试文件: `test_other/test_cosθ_half_precision.jl`
- API 文档: `docs/api/GaussLegendre.md`
- 源代码: `src/integration/GaussLegendre.jl`
