# C++ 中 dubar 和 subar 散射过程的介子分析

## 1. 问题背景

在 C++ 代码 `PNJL.h` 中，散射过程编码包含了两个 Julia 文档中未明确列出的过程：
- **dub_code**: $d\bar{u} \to d\bar{u}$ 散射
- **sub_code**: $s\bar{u} \to s\bar{u}$ 散射

根据 Julia 文档（`ScatteringProcesses_AllPossible.md` 表2），独立的夸克-反夸克散射过程只列出了：
- $u\bar{d} \to u\bar{d}$
- $u\bar{s} \to u\bar{s}$
- $u\bar{u} \to u\bar{u}$, $u\bar{u} \to d\bar{d}$, $u\bar{u} \to s\bar{s}$
- $s\bar{s} \to u\bar{u}$, $s\bar{s} \to s\bar{s}$

看起来缺少了 $d\bar{u}$ 和 $s\bar{u}$ 过程。

---

## 2. C++ 代码中的散射过程定义

### 2.1 dub_code 的定义

```cpp
const int dub_code[3][4] = { {1, 0, 1, 0}, {0, 1, 0, 1}, {1, -1, 1, 1} };
// d + ū → d + ū
```

**编码解析：**
- `code[0][4] = {1, 0, 1, 0}`：粒子味标记（d, u, d, u）
- `code[1][4] = {0, 1, 0, 1}`：粒子/反粒子标记（q, q̄, q, q̄）
- `code[2][4] = {1, -1, 1, 1}`：传播子通道控制
  - `{1, -1, 1, 1}`：t 道重介子(-1)、s 道轻介子(1)

**物理过程：** $d + \bar{u} \to d + \bar{u}$（d 夸克与 u 反夸克的散射）

### 2.2 sub_code 的定义

```cpp
const int sub_code[3][4] = { {2, 0, 2, 0}, {0, 1, 0, 1}, {1, -1, -1, 1} };
// s + ū → s + ū
```

**编码解析：**
- `code[0][4] = {2, 0, 2, 0}`：粒子味标记（s, u, s, u）
- `code[1][4] = {0, 1, 0, 1}`：粒子/反粒子标记（q, q̄, q, q̄）
- `code[2][4] = {1, -1, -1, 1}`：传播子通道控制
  - `{1, -1, -1, 1}`：t 道重介子(-1)、s 道重介子(-1)

**物理过程：** $s + \bar{u} \to s + \bar{u}$（s 夸克与 u 反夸克的散射）

---

## 3. 与 Julia 文档的对应关系

### 3.1 同位旋对称性与电荷共轭

Julia 文档基于 **同位旋对称**（u 和 d 夸克质量相等），因此：

$$
d\bar{u} \to d\bar{u} \quad \text{与} \quad u\bar{d} \to u\bar{d} \quad \text{在物理上等价}
$$

$$
s\bar{u} \to s\bar{u} \quad \text{与} \quad u\bar{s} \to u\bar{s} \quad \text{在物理上等价}
$$

**关键差异：**
- Julia 文档选择了 $u\bar{d}$ 和 $u\bar{s}$ 作为代表性过程
- C++ 代码为了完整性，**同时实现了电荷共轭过程** $d\bar{u}$ 和 $s\bar{u}$

**物理正当性：**
- 在 **同位旋对称极限** 下，$d\bar{u}$ 和 $u\bar{d}$ 的散射矩阵元完全相同
- 但在 **驰豫时间计算** 中，需要分别对不同粒子组合求和，因此 C++ 代码明确区分了两者

### 3.2 为什么 Julia 文档没有明确列出？

根据 `额外散射过程推理.md`，Julia 文档说明：

> "由于同位旋对称和电荷共轭对称，过程 $s\bar{u} \to s\bar{u}$ 与 $u\bar{s} \to u\bar{s}$ 类似。"

这表明：
1. Julia 文档 **隐式包含** 了这些过程
2. 在实际计算中，通过 **对称性关系** 自动处理
3. C++ 代码选择 **显式编码**，避免运行时推导

---

## 4. 有效介子分析

### 4.1 dub 过程：$d\bar{u} \to d\bar{u}$

根据 Julia 文档的 `额外散射过程推理.md` 和 `ScatteringProcesses_AllPossible.md` 表2，$d\bar{u}$ 过程与 $u\bar{d}$ 过程的介子种类完全相同：

#### t 道（交换）：
夸克对 $d\bar{d}$ 和 $u\bar{u}$ 都可以形成以下介子：
- **赝标量介子**：$\pi$, $\eta$, $\eta'$
- **标量介子**：$\sigma_\pi$, $\sigma$, $\sigma'$

**原因：**
- t 道交换介子连接 $(d, u)$ 对和 $(\bar{u}, \bar{d})$ 对
- 这些介子都是 **味中性** 的（奇异数 S=0）
- 可以同时耦合到轻夸克对 $u\bar{u}$, $d\bar{d}$

#### s 道（湮灭）：
初末态 $d\bar{u}$ 直接湮灭形成：
- **赝标量介子**：$\pi^-$（或一般记为 $\pi$）
- **标量介子**：$\sigma_\pi$（对应 $a_0(980)$）

**原因：**
- $d\bar{u}$ 的量子数：奇异数 S=0，电荷 Q=-1
- 对应 $\pi^-$ 和其标量伙伴 $a_0^-$

**C++ 代码验证：**
```cpp
code[2][4] = {1, -1, 1, 1}
// t 道：code[2][2] = 1（轻介子）但会被重写为 -1（见下文分析）
// s 道：code[2][3] = 1（轻介子）
```

注意：`code[2][2] = 1` 在代码中可能被特殊处理为重介子，因为 t 道需要包含 $\eta/\eta'$ 等混合态介子。

#### 完整介子列表：

| 散射道 | 可能的介子 |
|--------|-----------|
| **t 道** | $\pi$, $\eta$, $\eta'$, $\sigma_\pi$, $\sigma$, $\sigma'$ |
| **s 道** | $\pi$, $\sigma_\pi$ |

### 4.2 sub 过程：$s\bar{u} \to s\bar{u}$

根据 `额外散射过程推理.md` 的详细分析，$s\bar{u}$ 过程与 $u\bar{s}$ 过程的介子种类相同：

#### t 道（交换）：
夸克对 $s\bar{s}$ 和 $u\bar{u}$ 形成的味中性介子：
- **赝标量介子**：$\eta$, $\eta'$（含 $s\bar{s}$ 成分）
- **标量介子**：$\sigma$, $\sigma'$（对应 $f_0(500)$, $f_0(1370)$）

**排除的介子：**
- ❌ $\pi$：纯 $u\bar{u} + d\bar{d}$ 组合，不含 $s\bar{s}$ 成分，无法连接 s 夸克
- ❌ $\sigma_\pi$：类似 $\pi$ 的标量版本
- ❌ $K$, $\sigma_K$：带奇异数，无法在 t 道（味中性）交换

#### s 道（湮灭）：
初末态 $s\bar{u}$ 直接湮灭形成：
- **赝标量介子**：$K^-$（或一般记为 $K$）
- **标量介子**：$\sigma_K$（对应 $K_0^*(700)$）

**原因：**
- $s\bar{u}$ 的量子数：奇异数 S=-1，电荷 Q=-1
- 对应 $K^-$ 和其标量伙伴 $K_0^{*-}$

**C++ 代码验证：**
```cpp
code[2][4] = {1, -1, -1, 1}
// t 道：code[2][2] = -1（重介子，对应 η/η'/σ/σ'）
// s 道：code[2][3] = 1 但由于 q4 组合会使用重介子处理（？）
```

实际上，K 介子应该使用 **轻介子传播子** `propagator_l`，因为虽然含 s 夸克，但不参与 $\lambda_0$-$\lambda_8$ 混合。

#### 完整介子列表：

| 散射道 | 可能的介子 |
|--------|-----------|
| **t 道** | $\eta$, $\eta'$, $\sigma$, $\sigma'$ |
| **s 道** | $K$, $\sigma_K$ |

---

## 5. C++ 代码实现细节

### 5.1 在 set_rex_time 中的调用

```cpp
void PNJL::set_rex_time() {
    // ... 其他散射过程 ...
    
    // 新增的 qq̄ 散射过程
    averaged_rate(dub_code, wqb[7], wqbn[7]);  // dū → dū
    averaged_rate(sub_code, wqb[8], wqbn[8]);  // sū → sū
    
    // 在驰豫时间中的使用
    tau[0][0] = 1.0 / (... + n_ub * (wqb[0] + wqb[1] + wqb[2] + wqb[3]) + ...);
    tau[0][1] = 1.0 / (n_u * (wqb[1] + wqb[2] + wqb[3] + wqb[7]) + ...);
    //                                                      ^^^^^ dub 的贡献
    tau[2][0] = 1.0 / (... + 2.0 * n_ub * wqb[8] + ...);
    //                                     ^^^^^^^ sub 的贡献（×2 因子）
}
```

**关键观察：**
1. `wqb[7]` 对应 $d\bar{u}$ 过程，影响 **u 反夸克** 的驰豫时间 `tau[0][1]`
2. `wqb[8]` 对应 $s\bar{u}$ 过程，影响 **s 夸克** 的驰豫时间 `tau[2][0]`
3. `sub` 过程有 **2.0 倍权重**，可能因为同位旋因子或对称性

### 5.2 与 udb_code 和 usb_code 的对比

```cpp
const int udb_code[3][4] = { {0, 1, 0, 1}, {0, 1, 0, 1}, {1, -1, 1, 1} }; // ud̄ → ud̄
const int dub_code[3][4] = { {1, 0, 1, 0}, {0, 1, 0, 1}, {1, -1, 1, 1} }; // dū → dū

const int usb_code[3][4] = { {0, 2, 0, 2}, {0, 1, 0, 1}, {1, -1, -1, 1} }; // us̄ → us̄
const int sub_code[3][4] = { {2, 0, 2, 0}, {0, 1, 0, 1}, {1, -1, -1, 1} }; // sū → sū
```

**唯一差异：** `code[0]` 数组中初末态粒子的顺序互换
- `udb`: {u, d̄, u, d̄} → 夸克在前，反夸克在后
- `dub`: {d, ū, d, ū} → 夸克在前，反夸克在后（但 u/d 角色互换）

**物理等价性：** 在同位旋对称下，两者散射矩阵元相同，但数密度 $n_d \neq n_u$ 时会有差异。

---

## 6. Julia 项目中的对应实现

### 6.1 隐式处理

Julia 文档在 `额外散射过程推理.md` 中明确说明：

> "由于同位旋对称和电荷共轭对称，过程 $s\bar{u} \to s\bar{u}$ 与 $u\bar{s} \to u\bar{s}$ 类似。"

这表明 Julia 代码可能：
1. **仅实现 $u\bar{d}$ 和 $u\bar{s}$**，通过对称性自动生成 $d\bar{u}$ 和 $s\bar{u}$
2. 或者在 **自动化散射过程生成器** 中包含所有组合

### 6.2 验证方法

查看 Julia 代码的散射过程生成函数（如 `generate_all_processes`），应该能找到类似逻辑：

```julia
# 伪代码
for q1 in [:u, :d, :s]
    for q2_bar in [:ubar, :dbar, :sbar]
        if isospin_symmetric && (q1 == :d && q2_bar == :ubar)
            # 使用 u + dbar 的结果，或独立计算
            process = ScatteringProcess(q1, q2_bar, ...)
        end
    end
end
```

---

## 7. 总结

### 7.1 核心发现

1. **C++ 中的 dub 和 sub 过程并非"多出来"**，而是 Julia 文档中 **通过对称性隐式包含** 的过程的显式实现。

2. **有效介子种类完全对应：**
   - $d\bar{u} \to d\bar{u}$ ⟷ $u\bar{d} \to u\bar{d}$（同位旋对称）
   - $s\bar{u} \to s\bar{u}$ ⟷ $u\bar{s} \to u\bar{s}$（电荷共轭对称）

3. **介子列表：**

| 散射过程 | t 道介子 | s 道介子 |
|----------|----------|----------|
| $d\bar{u} \to d\bar{u}$ | $\pi$, $\eta$, $\eta'$, $\sigma_\pi$, $\sigma$, $\sigma'$ | $\pi$, $\sigma_\pi$ |
| $s\bar{u} \to s\bar{u}$ | $\eta$, $\eta'$, $\sigma$, $\sigma'$ | $K$, $\sigma_K$ |

### 7.2 物理意义

- **C++ 的显式实现** 优势：
  - 代码清晰，易于追踪每个过程的贡献
  - 在 **同位旋破缺** 情况下更灵活（$m_u \neq m_d$）
  - 驰豫时间计算中需要区分不同粒子的数密度

- **Julia 的隐式实现** 优势：
  - 代码简洁，利用对称性减少重复
  - 便于自动化生成所有可能的散射过程
  - 理论上更优雅，强调物理对称性

### 7.3 验证建议

1. **数值验证**：
   - 计算 $u\bar{d}$ 和 $d\bar{u}$ 的散射矩阵元，应该在同位旋对称下完全相等
   - 检查 C++ 中 `wqb[0]`（udb）和 `wqb[7]`（dub）的数值关系

2. **代码交叉检查**：
   - 在 Julia 代码中搜索是否有自动生成电荷共轭过程的函数
   - 确认 `ScatteringAmplitude.jl` 如何处理 $d\bar{u}$ 类型的输入

3. **物理一致性**：
   - 验证驰豫时间 $\tau$ 的计算是否包含所有必要的散射通道
   - 检查粘滞系数 $\eta/s$ 在两种实现下是否一致

---

## 附录：C++ 代码片段

### A.1 散射过程编码定义

```cpp
// PNJL.h 第 259-260 行
const int dub_code[3][4] = { {1, 0, 1, 0}, {0, 1, 0, 1}, {1, -1, 1, 1} }; 
const int sub_code[3][4] = { {2, 0, 2, 0}, {0, 1, 0, 1}, {1, -1, -1, 1} };
```

### A.2 驰豫时间计算

```cpp
// PNJL_rextime.cpp 第 39-40 行
averaged_rate(dub_code, wqb[7], wqbn[7]);
averaged_rate(sub_code, wqb[8], wqbn[8]);

// 第 48-53 行
tau[0][1] = 1.0 / (n_u * (wqb[1] + wqb[2] + wqb[3] + wqb[7]) + ...);
tau[2][0] = 1.0 / (... + 2.0 * n_ub * wqb[8] + ...);
```

### A.3 编码格式说明

```cpp
// 编码含义：code[3][4]
// code[0][i]: 粒子味量子数 (0=u, 1=d, 2=s)
// code[1][i]: 粒子类型 (0=quark, 1=antiquark)
// code[2][i]: 传播子通道 (1=light, -1=heavy)
```

**文档版本**：v1.0  
**最后更新**：2025-01-13  
**作者**：基于 PNJL_rex_time C++ 项目与 Julia 项目对比分析
