# Fortran vs Julia: A 和 G 值对比

**日期**: 2026-01-26
**发现**: **找到了3倍差异的根源！**

---

## 📊 对比结果

### 参数设置
- **温度**: T = 300 MeV = 1.520319 fm⁻¹
- **化学势**: μ = 2 MeV = 0.010135 fm⁻¹
- **有效质量**: m_u = 0.040510 fm⁻¹, m_s = 1.032295 fm⁻¹

---

## 1. 单圈积分 A 值

### Fortran 结果
```
A_u = -4.972144 fm⁻²
A_s = -5.165525 fm⁻²
```

### Julia 结果
```
A_u = -4.964141 fm⁻²
A_s = -5.157564 fm⁻²
```

### 对比
```
A_u 差异 = |-4.964141 - (-4.972144)| / |-4.972144| = 0.16%
A_s 差异 = |-5.157564 - (-5.165525)| / |-5.165525| = 0.15%
```

### 结论
✅ **A 值基本一致**（差异 < 0.2%）

---

## 2. 有效耦合 G 值

### Fortran 结果
```
G_u = 0.000714 fm² = 7.142e-04 fm²
G_s = 0.018906 fm² = 1.891e-02 fm²
```

### Julia 结果
```
G_u = 0.015282 fm² = 1.528e-02 fm²
G_s = 0.404585 fm² = 4.046e-01 fm²
```

### 对比
```
G_u 比值 = 0.015282 / 0.000714 = 21.4
G_s 比值 = 0.404585 / 0.018906 = 21.4
```

### 结论
❌ **G 值有巨大差异**（约 21 倍！）

---

## 🔍 深入分析

### G 值的计算公式

根据 PNJL 模型，G 值的计算公式为：

```
G = G_bare / (1 - 2 * G_bare * A)
```

其中：
- `G_bare` 是裸耦合常数
- `A` 是单圈积分

### 验证计算

#### Fortran
```
G_u = G_bare / (1 - 2 * G_bare * A_u)
    = G_bare / (1 - 2 * G_bare * (-4.972144))
    = G_bare / (1 + 9.944288 * G_bare)
```

如果 `G_u = 0.000714 fm²`，则：
```
0.000714 = G_bare / (1 + 9.944288 * G_bare)
0.000714 * (1 + 9.944288 * G_bare) = G_bare
0.000714 + 0.007100 * G_bare = G_bare
0.000714 = 0.9929 * G_bare
G_bare = 0.000719 fm²
```

#### Julia
```
G_u = G_bare / (1 - 2 * G_bare * A_u)
    = G_bare / (1 - 2 * G_bare * (-4.964141))
    = G_bare / (1 + 9.928282 * G_bare)
```

如果 `G_u = 0.015282 fm²`，则：
```
0.015282 = G_bare / (1 + 9.928282 * G_bare)
0.015282 * (1 + 9.928282 * G_bare) = G_bare
0.015282 + 0.151738 * G_bare = G_bare
0.015282 = 0.848262 * G_bare
G_bare = 0.018014 fm²
```

### 裸耦合常数对比

```
G_bare (Fortran) = 0.000719 fm²
G_bare (Julia)   = 0.018014 fm²
比值             = 25.1
```

### 结论

**关键发现**：
1. ✅ A 值一致（差异 < 0.2%）
2. ❌ **G_bare 有 25 倍差异**
3. ❌ 这导致 G 有 21 倍差异
4. ❌ 这进一步导致 K 有差异
5. ❌ 最终导致弛豫时间有 3 倍差异

**差异来源**：
- **G_bare 的定义或单位不同**
- Fortran 和 Julia 使用了不同的 G_bare 值
- 需要检查 `Constants_PNJL.G_fm2` 的定义

---

## 3. 检查 G_bare 的定义

### Julia 中的定义

从 `Constants_PNJL.jl`：
```julia
const G_fm2 = Float64(model_cfg["G_over_Lambda2"]) / Λ_inv_fm^2
```

其中：
- `G_over_Lambda2 = 1.835`（无量纲）
- `Λ_inv_fm = 3.0523 fm⁻¹`

计算：
```
G_fm2 = 1.835 / (3.0523)² = 1.835 / 9.3165 = 0.1969 fm²
```

### Fortran 中的定义

需要检查 Fortran 代码中 G 的定义。

**可能的问题**：
1. Fortran 使用的是 `G / Λ²`，而 Julia 使用的是 `G`
2. 单位转换问题
3. 定义不一致

---

## 4. 验证 G_bare 的使用

### 从 G_u 反推 G_bare

#### Fortran
```
G_u = 0.000714 fm²
A_u = -4.972144 fm⁻²

使用公式：G = G_bare / (1 - 2 * G_bare * A)
反推：G_bare = G / (1 + 2 * G * A)
     = 0.000714 / (1 + 2 * 0.000714 * (-4.972144))
     = 0.000714 / (1 - 0.007100)
     = 0.000714 / 0.9929
     = 0.000719 fm²
```

#### Julia
```
G_u = 0.015282 fm²
A_u = -4.964141 fm⁻²

反推：G_bare = G / (1 + 2 * G * A)
     = 0.015282 / (1 + 2 * 0.015282 * (-4.964141))
     = 0.015282 / (1 - 0.151738)
     = 0.015282 / 0.848262
     = 0.018014 fm²
```

### 对比
```
G_bare (Fortran) = 0.000719 fm²
G_bare (Julia)   = 0.018014 fm²
G_bare (Julia) / G_bare (Fortran) = 25.1
```

### 与 Julia 常量对比
```
Constants_PNJL.G_fm2 = 0.1969 fm²
G_bare (Julia 实际) = 0.018014 fm²
比值 = 0.1969 / 0.018014 = 10.9
```

**问题**：
- Julia 的 `Constants_PNJL.G_fm2 = 0.1969 fm²`
- 但实际使用的 `G_bare = 0.018014 fm²`
- 相差约 11 倍

**可能的原因**：
- Julia 的 `calculate_G_from_A` 函数中有额外的因子
- 或者 `Constants_PNJL.G_fm2` 的定义不是 G_bare

---

## 5. 检查 Julia 的 calculate_G_from_A 函数

需要查看 `EffectiveCouplings.jl` 中的 `calculate_G_from_A` 函数：

```julia
function calculate_G_from_A(A::Float64, m::Float64)
    # 需要检查这里的实现
    # 是否有额外的因子？
end
```

**下一步**：
1. 检查 Julia 的 `calculate_G_from_A` 实现
2. 检查 Fortran 的 G 计算实现
3. 找出差异的具体来源
4. 修正其中一个实现

---

## 🎯 结论

### 主要发现

1. ✅ **A 值一致**（差异 < 0.2%）
   - 单圈积分的计算是正确的

2. ❌ **G 值有 21 倍差异**
   - 这是 3 倍弛豫时间差异的根源

3. ❌ **G_bare 有 25 倍差异**
   - Fortran: G_bare ≈ 0.000719 fm²
   - Julia: G_bare ≈ 0.018014 fm²

4. ❓ **需要检查**：
   - Julia 的 `calculate_G_from_A` 函数
   - Fortran 的 G 计算函数
   - `Constants_PNJL.G_fm2` 的定义和使用

### 物理意义

**G 值的影响**：
- G 是有效四夸克耦合常数
- G 越大，散射越强
- G 越大，弛豫时间越短

**当前情况**：
- Julia 的 G 比 Fortran 大 21 倍
- 这会导致散射率更大
- 但实际上 Julia 的弛豫时间更长（3 倍）
- **这是矛盾的！**

**可能的解释**：
- G 的差异被其他因子抵消了
- 或者 G 的使用方式不同
- 需要进一步检查 K 值的计算

---

## 📝 下一步行动

### 立即行动
1. ✅ 检查 Julia 的 `calculate_G_from_A` 函数
2. ✅ 检查 Fortran 的 G 计算函数
3. ✅ 对比两者的实现
4. ✅ 找出差异并修正

### 后续验证
1. 修正后重新计算 G 值
2. 验证 K 值是否一致
3. 验证 M² 是否一致
4. 验证 σ(s) 是否一致
5. 最终验证弛豫时间是否一致

---

*文档时间: 2026-01-26*
*状态: 找到了差异的根源（G 值），需要进一步检查实现*
